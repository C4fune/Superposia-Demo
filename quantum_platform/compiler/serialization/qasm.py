"""
OpenQASM Export and Import

This module provides functionality to export quantum circuits to OpenQASM format
and import OpenQASM files back to quantum circuits.
"""

import re
import math
from typing import Dict, List, Optional, Set, Tuple, Any, Union
from dataclasses import dataclass

from quantum_platform.compiler.ir.circuit import QuantumCircuit, ClassicalRegister
from quantum_platform.compiler.ir.operation import (
    Operation, GateOperation, MeasurementOperation, ResetOperation, 
    BarrierOperation, IfOperation, LoopOperation
)
from quantum_platform.compiler.ir.qubit import Qubit
from quantum_platform.compiler.gates.registry import get_gate
from quantum_platform.compiler.serialization.formats import ExportOptions, ImportOptions


class QasmExportError(Exception):
    """Exception raised during QASM export."""
    pass


class QasmImportError(Exception):
    """Exception raised during QASM import."""
    pass


@dataclass
class QasmGateDefinition:
    """Definition of a gate in QASM format."""
    name: str
    parameters: List[str]
    qubits: List[str]
    body: List[str]


class QasmExporter:
    """
    Export quantum circuits to OpenQASM format.
    
    Supports both QASM 2.0 and QASM 3.0 with various compatibility modes.
    """
    
    def __init__(self):
        self._gate_definitions = {}
        self._used_gates = set()
        
        # QASM 2.0 standard gates
        self._qasm2_standard_gates = {
            'u1', 'u2', 'u3', 'cx', 'id', 'x', 'y', 'z', 'h', 's', 't', 'sdg', 'tdg',
            'rx', 'ry', 'rz', 'cz', 'cy', 'swap', 'ch', 'ccx', 'cswap', 'crz', 'cu1', 'cu3'
        }
        
        # Gate name mappings for compatibility
        self._gate_mappings = {
            'i': 'id',
            'cnot': 'cx',
            'toffoli': 'ccx',
            'fredkin': 'cswap'
        }
    
    def export(self, circuit: QuantumCircuit, options: Optional[ExportOptions] = None) -> str:
        """
        Export a quantum circuit to QASM format.
        
        Args:
            circuit: The quantum circuit to export
            options: Export options controlling the output format
            
        Returns:
            QASM representation as a string
            
        Raises:
            QasmExportError: If export fails
        """
        if options is None:
            options = ExportOptions()
        
        try:
            self._reset_state()
            
            if options.format.value == "qasm2":
                return self._export_qasm2(circuit, options)
            elif options.format.value == "qasm3":
                return self._export_qasm3(circuit, options)
            else:
                raise QasmExportError(f"Unsupported format: {options.format}")
                
        except Exception as e:
            raise QasmExportError(f"Failed to export circuit: {str(e)}")
    
    def _reset_state(self):
        """Reset exporter state for new export."""
        self._gate_definitions.clear()
        self._used_gates.clear()
    
    def _export_qasm2(self, circuit: QuantumCircuit, options: ExportOptions) -> str:
        """Export to QASM 2.0 format."""
        lines = []
        
        # Header
        lines.append("OPENQASM 2.0;")
        lines.append('include "qelib1.inc";')
        lines.append("")
        
        if options.include_comments:
            lines.append(f"// Circuit: {circuit.name}")
            lines.append(f"// Qubits: {circuit.num_qubits}, Operations: {circuit.num_operations}")
            lines.append("")
        
        # Quantum register declaration
        lines.append(f"qreg q[{circuit.num_qubits}];")
        
        # Classical register declarations
        for reg_name, reg in circuit.classical_registers.items():
            lines.append(f"creg {reg_name}[{reg.size}];")
        
        lines.append("")
        
        # Operations
        for operation in circuit.operations:
            qasm_line = self._operation_to_qasm2(operation, circuit, options)
            if qasm_line:
                lines.append(qasm_line)
        
        return "\n".join(lines)
    
    def _export_qasm3(self, circuit: QuantumCircuit, options: ExportOptions) -> str:
        """Export to QASM 3.0 format."""
        lines = []
        
        # Header
        lines.append("OPENQASM 3.0;")
        lines.append("")
        
        if options.include_comments:
            lines.append(f"// Circuit: {circuit.name}")
            lines.append(f"// Generated by Quantum Platform")
            lines.append("")
        
        # Include standard library
        lines.append('include "stdgates.inc";')
        lines.append("")
        
        # Qubit declarations
        if circuit.num_qubits == 1:
            lines.append("qubit q;")
        else:
            lines.append(f"qubit[{circuit.num_qubits}] q;")
        
        # Classical register declarations
        for reg_name, reg in circuit.classical_registers.items():
            if reg.size == 1:
                lines.append(f"bit {reg_name};")
            else:
                lines.append(f"bit[{reg.size}] {reg_name};")
        
        lines.append("")
        
        # Operations
        for operation in circuit.operations:
            qasm_line = self._operation_to_qasm3(operation, circuit, options)
            if qasm_line:
                lines.append(qasm_line)
        
        return "\n".join(lines)
    
    def _operation_to_qasm2(self, operation: Operation, circuit: QuantumCircuit, options: ExportOptions) -> Optional[str]:
        """Convert an operation to QASM 2.0 syntax."""
        if isinstance(operation, GateOperation):
            return self._gate_to_qasm2(operation, options)
        elif isinstance(operation, MeasurementOperation):
            return self._measurement_to_qasm2(operation)
        elif isinstance(operation, ResetOperation):
            return self._reset_to_qasm2(operation)
        elif isinstance(operation, BarrierOperation):
            if options.include_barriers:
                return self._barrier_to_qasm2(operation)
        elif isinstance(operation, IfOperation):
            # QASM 2.0 doesn't support conditionals well, but we can try
            return self._conditional_to_qasm2(operation, circuit, options)
        
        return None
    
    def _operation_to_qasm3(self, operation: Operation, circuit: QuantumCircuit, options: ExportOptions) -> Optional[str]:
        """Convert an operation to QASM 3.0 syntax."""
        if isinstance(operation, GateOperation):
            return self._gate_to_qasm3(operation, options)
        elif isinstance(operation, MeasurementOperation):
            return self._measurement_to_qasm3(operation)
        elif isinstance(operation, ResetOperation):
            return self._reset_to_qasm3(operation)
        elif isinstance(operation, BarrierOperation):
            if options.include_barriers:
                return self._barrier_to_qasm3(operation)
        elif isinstance(operation, IfOperation):
            return self._conditional_to_qasm3(operation, circuit, options)
        elif isinstance(operation, LoopOperation):
            return self._loop_to_qasm3(operation, circuit, options)
        
        return None
    
    def _gate_to_qasm2(self, gate_op: GateOperation, options: ExportOptions) -> str:
        """Convert gate operation to QASM 2.0 syntax."""
        gate_name = self._gate_mappings.get(gate_op.name.lower(), gate_op.name.lower())
        
        # Build target qubits
        targets = [f"q[{q.id}]" for q in gate_op.targets]
        controls = [f"q[{q.id}]" for q in gate_op.controls]
        
        # Handle parameters
        if gate_op.params:
            param_list = []
            for param_name in ['theta', 'phi', 'lambda', 'angle']:
                if param_name in gate_op.params:
                    param_list.append(str(gate_op.params[param_name]))
            
            if param_list:
                params_str = "(" + ",".join(param_list) + ")"
            else:
                params_str = ""
        else:
            params_str = ""
        
        # Build full qubit list (controls first, then targets)
        all_qubits = controls + targets
        qubits_str = ",".join(all_qubits)
        
        return f"{gate_name}{params_str} {qubits_str};"
    
    def _gate_to_qasm3(self, gate_op: GateOperation, options: ExportOptions) -> str:
        """Convert gate operation to QASM 3.0 syntax."""
        gate_name = gate_op.name.lower()
        
        # Build target qubits
        targets = [f"q[{q.id}]" for q in gate_op.targets]
        
        # Handle controlled gates
        if gate_op.controls:
            controls = [f"q[{q.id}]" for q in gate_op.controls]
            # In QASM 3, controlled gates use ctrl @ syntax
            ctrl_str = f"ctrl({len(controls)}) @ "
            all_qubits = controls + targets
        else:
            ctrl_str = ""
            all_qubits = targets
        
        # Handle parameters
        if gate_op.params:
            param_list = []
            for param_name in ['theta', 'phi', 'lambda', 'angle']:
                if param_name in gate_op.params:
                    param_list.append(str(gate_op.params[param_name]))
            
            if param_list:
                params_str = "(" + ",".join(param_list) + ") "
            else:
                params_str = ""
        else:
            params_str = ""
        
        qubits_str = ",".join(all_qubits)
        return f"{ctrl_str}{gate_name}{params_str} {qubits_str};"
    
    def _measurement_to_qasm2(self, measure_op: MeasurementOperation) -> str:
        """Convert measurement to QASM 2.0 syntax."""
        targets = [f"q[{q.id}]" for q in measure_op.targets]
        
        if measure_op.classical_target:
            reg_name = measure_op.classical_target
            if len(targets) == 1:
                return f"measure {targets[0]} -> {reg_name}[0];"
            else:
                # Multi-qubit measurement
                lines = []
                for i, target in enumerate(targets):
                    lines.append(f"measure {target} -> {reg_name}[{i}];")
                return "\n".join(lines)
        else:
            # Measurement without classical storage
            return f"measure {','.join(targets)};"
    
    def _measurement_to_qasm3(self, measure_op: MeasurementOperation) -> str:
        """Convert measurement to QASM 3.0 syntax."""
        targets = [f"q[{q.id}]" for q in measure_op.targets]
        
        if measure_op.classical_target:
            reg_name = measure_op.classical_target
            if len(targets) == 1:
                return f"{reg_name} = measure {targets[0]};"
            else:
                return f"{reg_name} = measure {{{','.join(targets)}}};"
        else:
            return f"measure {{{','.join(targets)}}};"
    
    def _reset_to_qasm2(self, reset_op: ResetOperation) -> str:
        """Convert reset to QASM 2.0 syntax."""
        targets = [f"q[{q.id}]" for q in reset_op.targets]
        return f"reset {','.join(targets)};"
    
    def _reset_to_qasm3(self, reset_op: ResetOperation) -> str:
        """Convert reset to QASM 3.0 syntax."""
        targets = [f"q[{q.id}]" for q in reset_op.targets]
        return f"reset {','.join(targets)};"
    
    def _barrier_to_qasm2(self, barrier_op: BarrierOperation) -> str:
        """Convert barrier to QASM 2.0 syntax."""
        if barrier_op.targets:
            targets = [f"q[{q.id}]" for q in barrier_op.targets]
            return f"barrier {','.join(targets)};"
        else:
            return "barrier q;"
    
    def _barrier_to_qasm3(self, barrier_op: BarrierOperation) -> str:
        """Convert barrier to QASM 3.0 syntax."""
        if barrier_op.targets:
            targets = [f"q[{q.id}]" for q in barrier_op.targets]
            return f"barrier {','.join(targets)};"
        else:
            return "barrier q;"
    
    def _conditional_to_qasm2(self, if_op: IfOperation, circuit: QuantumCircuit, options: ExportOptions) -> str:
        """Convert conditional to QASM 2.0 (limited support)."""
        # QASM 2.0 has very limited conditional support
        # We'll do our best but this might not work in all parsers
        condition_str = f"if({if_op.condition_register}=={if_op.condition_value})"
        
        lines = []
        for op in if_op.then_operations:
            op_line = self._operation_to_qasm2(op, circuit, options)
            if op_line:
                lines.append(f"{condition_str} {op_line}")
        
        return "\n".join(lines)
    
    def _conditional_to_qasm3(self, if_op: IfOperation, circuit: QuantumCircuit, options: ExportOptions) -> str:
        """Convert conditional to QASM 3.0 syntax."""
        condition_str = f"if ({if_op.condition_register} == {if_op.condition_value})"
        
        lines = [condition_str + " {"]
        
        for op in if_op.then_operations:
            op_line = self._operation_to_qasm3(op, circuit, options)
            if op_line:
                lines.append("    " + op_line)
        
        if if_op.else_operations:
            lines.append("} else {")
            for op in if_op.else_operations:
                op_line = self._operation_to_qasm3(op, circuit, options)
                if op_line:
                    lines.append("    " + op_line)
        
        lines.append("}")
        return "\n".join(lines)
    
    def _loop_to_qasm3(self, loop_op: LoopOperation, circuit: QuantumCircuit, options: ExportOptions) -> str:
        """Convert loop to QASM 3.0 syntax."""
        if loop_op.loop_type == "for":
            loop_str = f"for int i in [0:{loop_op.iterations}]"
        else:
            # While loop - simplified
            loop_str = f"while ({loop_op.condition_register})"
        
        lines = [loop_str + " {"]
        
        for op in loop_op.body_operations:
            op_line = self._operation_to_qasm3(op, circuit, options)
            if op_line:
                lines.append("    " + op_line)
        
        lines.append("}")
        return "\n".join(lines)


class QasmImporter:
    """
    Import quantum circuits from OpenQASM format.
    
    Supports parsing QASM 2.0 and QASM 3.0 files and converting them
    to platform quantum circuits.
    """
    
    def __init__(self):
        self._qreg_size = 0
        self._qreg_name = "q"
        self._classical_registers = {}
        self._custom_gates = {}
    
    def import_from_string(self, qasm_string: str, options: Optional[ImportOptions] = None) -> QuantumCircuit:
        """
        Import a quantum circuit from QASM string.
        
        Args:
            qasm_string: QASM code as string
            options: Import options
            
        Returns:
            Quantum circuit
            
        Raises:
            QasmImportError: If parsing fails
        """
        if options is None:
            options = ImportOptions()
        
        try:
            return self._parse_qasm(qasm_string, options)
        except Exception as e:
            raise QasmImportError(f"Failed to parse QASM: {str(e)}")
    
    def import_from_file(self, file_path: str, options: Optional[ImportOptions] = None) -> QuantumCircuit:
        """
        Import a quantum circuit from QASM file.
        
        Args:
            file_path: Path to QASM file
            options: Import options
            
        Returns:
            Quantum circuit
            
        Raises:
            QasmImportError: If file reading or parsing fails
        """
        try:
            with open(file_path, 'r') as f:
                qasm_string = f.read()
            return self.import_from_string(qasm_string, options)
        except FileNotFoundError:
            raise QasmImportError(f"QASM file not found: {file_path}")
        except Exception as e:
            raise QasmImportError(f"Failed to read QASM file {file_path}: {str(e)}")
    
    def _parse_qasm(self, qasm_string: str, options: ImportOptions) -> QuantumCircuit:
        """Parse QASM string and build circuit."""
        self._reset_parser_state()
        
        # Clean and split lines
        lines = [line.strip() for line in qasm_string.split('\n')]
        lines = [line for line in lines if line and not line.startswith('//')]
        
        # Detect version
        version = self._detect_version(lines)
        
        # Create circuit
        circuit_name = "imported_circuit"
        circuit = QuantumCircuit(circuit_name, 0)  # Will allocate qubits based on registers
        
        # Parse lines
        for line_num, line in enumerate(lines, 1):
            try:
                self._parse_line(line, circuit, options, version)
            except Exception as e:
                if options.strict_parsing:
                    raise QasmImportError(f"Error at line {line_num}: {str(e)}")
                # In non-strict mode, skip problematic lines
                continue
        
        return circuit
    
    def _reset_parser_state(self):
        """Reset parser state for new import."""
        self._qreg_size = 0
        self._qreg_name = "q"
        self._classical_registers.clear()
        self._custom_gates.clear()
    
    def _detect_version(self, lines: List[str]) -> str:
        """Detect QASM version from header."""
        for line in lines:
            if line.startswith("OPENQASM"):
                if "2.0" in line:
                    return "2.0"
                elif "3.0" in line:
                    return "3.0"
        return "2.0"  # Default assumption
    
    def _parse_line(self, line: str, circuit: QuantumCircuit, options: ImportOptions, version: str):
        """Parse a single QASM line."""
        line = line.rstrip(';')
        
        if line.startswith("OPENQASM") or line.startswith("include"):
            return
        elif line.startswith("qreg") or line.startswith("qubit"):
            self._parse_qubit_declaration(line, circuit, options)
        elif line.startswith("creg") or line.startswith("bit"):
            self._parse_classical_declaration(line, circuit, options)
        elif line.startswith("measure"):
            self._parse_measurement(line, circuit, options)
        elif line.startswith("reset"):
            self._parse_reset(line, circuit, options)
        elif line.startswith("barrier"):
            self._parse_barrier(line, circuit, options)
        elif line.startswith("if"):
            self._parse_conditional(line, circuit, options, version)
        elif line.startswith("gate"):
            self._parse_gate_definition(line, options)
        else:
            # Assume it's a gate operation
            self._parse_gate_operation(line, circuit, options)
    
    def _parse_qubit_declaration(self, line: str, circuit: QuantumCircuit, options: ImportOptions):
        """Parse qubit register declaration."""
        # Handle both QASM 2 (qreg q[5];) and QASM 3 (qubit[5] q;)
        if line.startswith("qreg"):
            # QASM 2: qreg q[5];
            match = re.match(r'qreg\s+(\w+)\[(\d+)\]', line)
            if match:
                self._qreg_name = match.group(1)
                self._qreg_size = int(match.group(2))
        else:
            # QASM 3: qubit[5] q; or qubit q;
            if '[' in line:
                match = re.match(r'qubit\[(\d+)\]\s+(\w+)', line)
                if match:
                    self._qreg_size = int(match.group(1))
                    self._qreg_name = match.group(2)
            else:
                match = re.match(r'qubit\s+(\w+)', line)
                if match:
                    self._qreg_size = 1
                    self._qreg_name = match.group(1)
        
        # Allocate qubits in circuit
        if self._qreg_size > 0:
            for i in range(self._qreg_size):
                circuit.allocate_qubit(f"{self._qreg_name}_{i}")
    
    def _parse_classical_declaration(self, line: str, circuit: QuantumCircuit, options: ImportOptions):
        """Parse classical register declaration."""
        # Handle both QASM 2 (creg c[5];) and QASM 3 (bit[5] c;)
        if line.startswith("creg"):
            # QASM 2: creg c[5];
            match = re.match(r'creg\s+(\w+)\[(\d+)\]', line)
            if match:
                reg_name = match.group(1)
                reg_size = int(match.group(2))
                circuit.add_classical_register(reg_name, reg_size)
                self._classical_registers[reg_name] = reg_size
        else:
            # QASM 3: bit[5] c; or bit c;
            if '[' in line:
                match = re.match(r'bit\[(\d+)\]\s+(\w+)', line)
                if match:
                    reg_size = int(match.group(1))
                    reg_name = match.group(2)
                    circuit.add_classical_register(reg_name, reg_size)
                    self._classical_registers[reg_name] = reg_size
            else:
                match = re.match(r'bit\s+(\w+)', line)
                if match:
                    reg_name = match.group(1)
                    circuit.add_classical_register(reg_name, 1)
                    self._classical_registers[reg_name] = 1
    
    def _parse_measurement(self, line: str, circuit: QuantumCircuit, options: ImportOptions):
        """Parse measurement operation."""
        # Handle both QASM 2 and QASM 3 styles
        if '->' in line:
            # QASM 2: measure q[0] -> c[0];
            parts = line.split('->')
            qubit_part = parts[0].strip().replace('measure', '').strip()
            classical_part = parts[1].strip()
            
            qubit_indices = self._parse_qubit_indices(qubit_part)
            classical_reg = self._parse_classical_target(classical_part)
            
        else:
            # QASM 3: c = measure q[0]; or c = measure {q[0], q[1]};
            if '=' in line:
                parts = line.split('=')
                classical_part = parts[0].strip()
                qubit_part = parts[1].strip().replace('measure', '').strip()
                
                qubit_indices = self._parse_qubit_indices(qubit_part)
                classical_reg = classical_part
            else:
                # Just measure without storing: measure q[0];
                qubit_part = line.replace('measure', '').strip()
                qubit_indices = self._parse_qubit_indices(qubit_part)
                classical_reg = None
        
        # Add measurement to circuit
        if qubit_indices:
            target_qubits = [circuit.qubits[i] for i in qubit_indices if i < len(circuit.qubits)]
            circuit.add_measurement(target_qubits, classical_reg)
    
    def _parse_gate_operation(self, line: str, circuit: QuantumCircuit, options: ImportOptions):
        """Parse gate operation."""
        # Extract gate name, parameters, and qubits
        # Handle format: gate_name(params) qubits;
        
        # Check for parameters
        if '(' in line:
            gate_part, rest = line.split('(', 1)
            gate_name = gate_part.strip()
            params_part, qubits_part = rest.split(')', 1)
            
            # Parse parameters
            params = {}
            if params_part.strip():
                param_values = [p.strip() for p in params_part.split(',')]
                # Map to common parameter names
                param_names = ['theta', 'phi', 'lambda']
                for i, value in enumerate(param_values):
                    if i < len(param_names):
                        try:
                            params[param_names[i]] = float(value)
                        except ValueError:
                            params[param_names[i]] = value  # Keep as string for symbolic
        else:
            parts = line.split()
            gate_name = parts[0]
            qubits_part = ' '.join(parts[1:])
            params = {}
        
        # Parse qubits
        qubit_indices = self._parse_qubit_indices(qubits_part)
        
        # Add gate to circuit
        if qubit_indices:
            target_qubits = [circuit.qubits[i] for i in qubit_indices if i < len(circuit.qubits)]
            if target_qubits:
                circuit.add_gate_operation(gate_name, target_qubits, params=params)
    
    def _parse_qubit_indices(self, qubit_part: str) -> List[int]:
        """Parse qubit indices from string like 'q[0],q[1]' or '{q[0],q[1]}'."""
        qubit_part = qubit_part.strip().strip('{}')
        indices = []
        
        # Handle comma-separated qubits
        for qubit_ref in qubit_part.split(','):
            qubit_ref = qubit_ref.strip()
            
            # Extract index from q[index] format
            match = re.search(r'\[(\d+)\]', qubit_ref)
            if match:
                indices.append(int(match.group(1)))
            elif qubit_ref and not qubit_ref.startswith(self._qreg_name):
                # Handle single qubit reference without brackets
                try:
                    indices.append(int(qubit_ref))
                except ValueError:
                    pass
        
        return indices
    
    def _parse_classical_target(self, classical_part: str) -> str:
        """Parse classical register target."""
        # Extract register name from c[0] format
        match = re.match(r'(\w+)', classical_part)
        if match:
            return match.group(1)
        return classical_part.strip()
    
    def _parse_reset(self, line: str, circuit: QuantumCircuit, options: ImportOptions):
        """Parse reset operation."""
        qubit_part = line.replace('reset', '').strip()
        qubit_indices = self._parse_qubit_indices(qubit_part)
        
        if qubit_indices:
            target_qubits = [circuit.qubits[i] for i in qubit_indices if i < len(circuit.qubits)]
            # Add reset operations (simplified - platform may need specific reset operation)
            for qubit in target_qubits:
                circuit.add_gate_operation("reset", [qubit])
    
    def _parse_barrier(self, line: str, circuit: QuantumCircuit, options: ImportOptions):
        """Parse barrier operation."""
        qubit_part = line.replace('barrier', '').strip()
        if qubit_part and qubit_part != self._qreg_name:
            qubit_indices = self._parse_qubit_indices(qubit_part)
            target_qubits = [circuit.qubits[i] for i in qubit_indices if i < len(circuit.qubits)]
        else:
            target_qubits = circuit.qubits  # All qubits
        
        if target_qubits:
            circuit.add_gate_operation("barrier", target_qubits)
    
    def _parse_conditional(self, line: str, circuit: QuantumCircuit, options: ImportOptions, version: str):
        """Parse conditional operation (simplified)."""
        # This is complex to implement fully - for now, just skip or do basic parsing
        # Full implementation would require parsing the condition and building IfOperation
        pass
    
    def _parse_gate_definition(self, line: str, options: ImportOptions):
        """Parse custom gate definition (simplified)."""
        # Custom gate definitions are complex - for now, just store the line
        # Full implementation would parse the gate body and register it
        pass 